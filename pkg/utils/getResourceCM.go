package utils
/*
      Licensed Materials - Property of IBM
      Â© IBM Corp. 2019
*/
import (
	"errors"
	"fmt"
	"github.com/chrisphillips-cminion/apiprofile/pkg/model"
	"gopkg.in/AlecAivazis/survey.v1"
	"os"
)

var realmAdmin = "admin/ldap-local"

func GetTopLevel() (model.TopLevel, error) {
	TraceEnter("GetTopLevel")
	orgId, name, err := GetCMOrgID()
	if err != nil {
		Trace(err.Error())
		TraceExit("GetTopLevel ERROR")
		return model.TopLevel{}, err
	}
	azs, err := GetAZs()
	if err != nil {
		Trace(err.Error())
		TraceExit("GetTopLevel ERROR")
		return model.TopLevel{}, err
	}
	members, err := getData("orgs", orgId, "members")
	if err != nil {
		Trace(err.Error())
		TraceExit("GetTopLevel ERROR")
		return model.TopLevel{}, err
	}
	memberInvites, err := getData("orgs", orgId, "member-invitations")
	if err != nil {
		Trace(err.Error())
		TraceExit("GetTopLevel ERROR")
		return model.TopLevel{}, err
	}
	mailserv, err := getData("orgs", orgId, "mail-servers")
	if err != nil {
		Trace(err.Error())
		TraceExit("GetTopLevel ERROR")
		return model.TopLevel{}, err
	}
	oauthp, err := getData("orgs", orgId, "oauth-providers")
	if err != nil {
		Trace(err.Error())
		TraceExit("GetTopLevel ERROR")
		return model.TopLevel{}, err
	}
	userreg, err := getData("orgs", orgId, "user-registries")
	if err != nil {
		Trace(err.Error())
		TraceExit("GetTopLevel ERROR")
		return model.TopLevel{}, err
	}
	orgNo, orgList, err := getOrgs()
	if err != nil {
		Trace(err.Error())
		TraceExit("GetTopLevel ERROR")
		return model.TopLevel{}, err
	}
	options := make([]string, orgNo)

	orgsToInvestigate := struct {
		POrg      []string
		SameCreds string
	}{}

	orgMap := make(map[string]orgNameId)
	for i, v := range *orgList {
		options[i] = v.Name
		orgMap[v.Name] = v
	}

	prompt := []*survey.Question{
		{
			Name: "pOrg",
			Prompt: &survey.MultiSelect{
				Message: "Which Provider Orgs would you like to investigate? :",
				Options: options,
			}}, {
			Name: "sameCreds",
			Prompt: &survey.Select{
				Message: "Do you want to use the same credentials for all Provier Organizations? :",
				Options: []string{"yes", "no"},
			},
		},
	}
	//Are we in a test case or not?
	if len(Vars.Orgs) >= 1 {
		orgsToInvestigate.SameCreds = "yes"
		orgsToInvestigate.POrg = Vars.Orgs
	} else {
		survey.Ask(prompt, &orgsToInvestigate)
	}
	access_token := "unset"
	// err := errors.New("Not an error")
	if orgsToInvestigate.SameCreds == "yes" {
		Vars.UserDetails = Vars.UserDetailsOrg
		access_token, err = Login(PromptCredentials("All", "provider"))
		if err != nil {
			Log("Unable to login to a APIM")
			os.Exit(2)
		}
	}
	org := make([]model.Organization, len(orgsToInvestigate.POrg))
	chanList := make(map[string]chan bool, len(orgsToInvestigate.POrg))
	for i, v := range orgsToInvestigate.POrg {
		fmt.Printf("\n\nLogging into %v\n\n",v)
		chanList[v] = make(chan bool)
		if access_token == "unset" {
			Vars.UserDetails = model.UserCreds{}
			err := errors.New("Not an error")
			Vars.Token, err = Login(PromptCredentials(v, "provider"))

			if err != nil {
				TraceExit("GetTopLevel ERROR - Probably invalid credentials")
				return model.TopLevel{}, err
			}
		} else {
			Vars.Token = access_token
		}
	// }
	// for i, v := range orgsToInvestigate.POrg {
		go asyncGetPorg(i, v, org, access_token, chanList, orgMap)
	}
	for _, v := range orgsToInvestigate.POrg {
		Log(v + " waiting.... ")
		<-chanList[v]
		Log(v + " complete.... ")
	}
	Trace(org)
	data := model.TopLevel{
		Name:            name,
		NoOrg:           orgNo,
		Org:             &org,
		NoMembers:       members,
		NoOauthP:        oauthp,
		NoUserReg:       userreg,
		NoMailServers:   mailserv,
		NoMemberInvites: memberInvites,
		Azs:             azs,
	}
	TraceExitReturn("GetTopLevel", data)
	return data, nil
}
func GetAZs() (*[]model.Az, error) {
	TraceEnter("GetAZs")

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	path := "orgs/admin/availability-zones"
	jsonObj, err := APICRequest(path)
	if err != nil {
		Trace(err.Error())
		TraceExit("GetAZs ERROR")
		return nil, err
	}
	// Trace(jsonObj)

	toReturn := make([]model.Az, int(jsonObj["total_results"].(float64)))
	for i, v := range jsonObj["results"].([]interface{}) {
		azId := v.(map[string]interface{})["id"].(string)
		apigw, v5cgw, err := NoOfGW(azId)
		if err != nil {
			Trace(err.Error())
			TraceExit("GetAZs ERROR")
			return nil, err
		}
		a7s, err := NoOfA7s(azId)
		if err != nil {
			Trace(err.Error())
			TraceExit("GetAZs ERROR")
			return nil, err
		}
		portal, err := NoOfPortals(azId)
		if err != nil {
			Trace(err.Error())
			TraceExit("GetAZs ERROR")
			return nil, err
		}
		toReturn[i] = model.Az{v.(map[string]interface{})["name"].(string), portal, a7s, v5cgw, apigw}
	}

	TraceExitReturn("GetAZs", toReturn)
	return &toReturn, nil
}

func NoOfGW(az string) (int, int, error) {
	TraceEnter("NoOfGW")
	path := "orgs/admin/availability-zones/" + az + "/gateway-services"
	jsonObj, err := APICRequest(path)
	if err != nil {
		Trace(err.Error())
		TraceExit("NoOfGW ERROR")
		return -1, -1, err
	}
	apiGW := 0
	v5cGW := 0
	for _, v := range jsonObj["results"].([]interface{}) {
		gwType := v.(map[string]interface{})["gateway_service_type"].(string)

		if gwType == "datapower-api-gateway" {
			apiGW++
		} else {
			v5cGW++
		}
	}
	TraceExitReturn("NoOfGW", fmt.Sprintf("APIGW %v\t V5CsGW %v", apiGW, v5cGW))
	return apiGW, v5cGW, nil
}

func NoOfA7s(az string) (int, error) {
	TraceEnter("NoOfA7s")
	path := "orgs/admin/availability-zones/" + az + "/analytics-services"
	jsonObj, err := APICRequest(path)
	if err != nil {
		Trace(err.Error())
		TraceExit("NoOfA7s ERROR")
		return -1, err
	}

	toReturn := int(jsonObj["total_results"].(float64))

	TraceExitReturn("NoOfA7s", fmt.Sprintf("A7s %v", toReturn))
	return toReturn, nil
}
func NoOfPortals(az string) (int, error) {
	TraceEnter("NoOfPortals")
	path := "orgs/admin/availability-zones/" + az + "/portal-services"
	jsonObj, err := APICRequest(path)
	if err != nil {
		Trace(err.Error())
		TraceExit("NoOfPortals ERROR")
		return -1, err
	}
	toReturn := int(jsonObj["total_results"].(float64))
	TraceExitReturn("NoOfPortals", fmt.Sprintf("Portal %v", toReturn))
	return toReturn, nil
}

func GetCMOrgID() (string, string, error) {
	TraceEnter("GetCMOrgID")
	Trace("https://apim.lts.apicww.cloud/api/orgs")
	// https://apim.lts.apicww.cloud/api/orgs
	path := "orgs"

	jsonObj, err := APICRequest(path)
	if err != nil {
		Trace(err.Error())
		TraceExit("GetCMOrgID ERROR")
		return "error", "error", err
	}
	toReturnId := jsonObj["results"].([]interface{})[0].(map[string]interface{})["id"].(string)
	toReturnName := jsonObj["results"].([]interface{})[0].(map[string]interface{})["name"].(string)
	TraceExitReturn("GetCMOrgID", fmt.Sprintf("Org ID %v \t Org Name %v", toReturnId, toReturnName))
	return toReturnId, toReturnName, nil
}

func getOrgs() (int, *[]orgNameId, error) {
	TraceEnter("getOrgs")

	path := "cloud/orgs"
	jsonObj, err := APICRequest(path)
	if err != nil {
		Trace(err.Error())
		TraceExit("getOrgs ERROR")
		return -1, nil, err
	}
	toReturnNo := int(jsonObj["total_results"].(float64))
	toReturnList := make([]orgNameId, toReturnNo)
	for i, v := range jsonObj["results"].([]interface{}) {
		d := v.(map[string]interface{})
		toReturnList[i] = orgNameId{Id: d["id"].(string), Name: d["name"].(string)}
	}
	TraceExitReturn("getOrgs", fmt.Sprintf("keyword %v", fmt.Sprintf("NoOfOrg %v \t orgList %v", toReturnNo, toReturnList)))
	return toReturnNo, &toReturnList, nil
}

type orgNameId struct {
	Name string
	Id   string
}

func asyncGetPorg(i int, localV string, org []model.Organization, access_token string, chanList map[string]chan bool, orgMap map[string]orgNameId) error {


	TraceEnter("asyncGetPorg")


	Log("Investigating Organization " + localV)
	err := errors.New("Not an error")
	org[i], err = GetPOrg(orgMap[localV], access_token)
	chanList[localV] <- true
	if err != nil {
		Trace(err.Error())
		TraceExit("asyncGetPorg ERROR")
		return err
	}
	Log("DONE " + localV)
	TraceExit("asyncGetPorg")
	return nil
}
